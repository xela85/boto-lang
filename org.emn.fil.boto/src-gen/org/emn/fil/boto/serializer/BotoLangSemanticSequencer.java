/*
 * generated by Xtext 2.10.0
 */
package org.emn.fil.boto.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.emn.fil.boto.botoLang.BotoLangPackage;
import org.emn.fil.boto.botoLang.Browser;
import org.emn.fil.boto.botoLang.Check;
import org.emn.fil.boto.botoLang.Click;
import org.emn.fil.boto.botoLang.Fill;
import org.emn.fil.boto.botoLang.Function;
import org.emn.fil.boto.botoLang.FunctionCall;
import org.emn.fil.boto.botoLang.Goto;
import org.emn.fil.boto.botoLang.Html;
import org.emn.fil.boto.botoLang.InstructionList;
import org.emn.fil.boto.botoLang.Model;
import org.emn.fil.boto.botoLang.Predicate;
import org.emn.fil.boto.botoLang.Put;
import org.emn.fil.boto.botoLang.Variable;
import org.emn.fil.boto.services.BotoLangGrammarAccess;

@SuppressWarnings("all")
public class BotoLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private BotoLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == BotoLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case BotoLangPackage.BROWSER:
				sequence_Browser(context, (Browser) semanticObject); 
				return; 
			case BotoLangPackage.CHECK:
				sequence_Check(context, (Check) semanticObject); 
				return; 
			case BotoLangPackage.CLICK:
				sequence_Click(context, (Click) semanticObject); 
				return; 
			case BotoLangPackage.FILL:
				sequence_Fill(context, (Fill) semanticObject); 
				return; 
			case BotoLangPackage.FUNCTION:
				sequence_Function(context, (Function) semanticObject); 
				return; 
			case BotoLangPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case BotoLangPackage.GOTO:
				sequence_Goto(context, (Goto) semanticObject); 
				return; 
			case BotoLangPackage.HTML:
				sequence_Html(context, (Html) semanticObject); 
				return; 
			case BotoLangPackage.INSTRUCTION_LIST:
				sequence_InstructionList(context, (InstructionList) semanticObject); 
				return; 
			case BotoLangPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case BotoLangPackage.OBJECT:
				sequence_Object(context, (org.emn.fil.boto.botoLang.Object) semanticObject); 
				return; 
			case BotoLangPackage.PREDICATE:
				sequence_Predicate(context, (Predicate) semanticObject); 
				return; 
			case BotoLangPackage.PUT:
				sequence_Put(context, (Put) semanticObject); 
				return; 
			case BotoLangPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Browser returns Browser
	 *
	 * Constraint:
	 *     (name=STRING instructions=InstructionList)
	 */
	protected void sequence_Browser(ISerializationContext context, Browser semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BotoLangPackage.Literals.BROWSER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BotoLangPackage.Literals.BROWSER__NAME));
			if (transientValues.isValueTransient(semanticObject, BotoLangPackage.Literals.BROWSER__INSTRUCTIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BotoLangPackage.Literals.BROWSER__INSTRUCTIONS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBrowserAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getBrowserAccess().getInstructionsInstructionListParserRuleCall_3_0(), semanticObject.getInstructions());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Check returns Check
	 *
	 * Constraint:
	 *     (object=Object predicate=Predicate)
	 */
	protected void sequence_Check(ISerializationContext context, Check semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BotoLangPackage.Literals.CHECK__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BotoLangPackage.Literals.CHECK__OBJECT));
			if (transientValues.isValueTransient(semanticObject, BotoLangPackage.Literals.CHECK__PREDICATE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BotoLangPackage.Literals.CHECK__PREDICATE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCheckAccess().getObjectObjectParserRuleCall_1_0(), semanticObject.getObject());
		feeder.accept(grammarAccess.getCheckAccess().getPredicatePredicateParserRuleCall_2_0(), semanticObject.getPredicate());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Click returns Click
	 *
	 * Constraint:
	 *     object=Object
	 */
	protected void sequence_Click(ISerializationContext context, Click semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BotoLangPackage.Literals.CLICK__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BotoLangPackage.Literals.CLICK__OBJECT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClickAccess().getObjectObjectParserRuleCall_1_0(), semanticObject.getObject());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Fill returns Fill
	 *
	 * Constraint:
	 *     (object=Object value=STRING)
	 */
	protected void sequence_Fill(ISerializationContext context, Fill semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BotoLangPackage.Literals.FILL__OBJECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BotoLangPackage.Literals.FILL__OBJECT));
			if (transientValues.isValueTransient(semanticObject, BotoLangPackage.Literals.FILL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BotoLangPackage.Literals.FILL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFillAccess().getObjectObjectParserRuleCall_1_0(), semanticObject.getObject());
		feeder.accept(grammarAccess.getFillAccess().getValueSTRINGTerminalRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (name=[Function|ID] (variables+=Variable variables+=Variable*)?)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Function returns Function
	 *
	 * Constraint:
	 *     (name=ID (variables+=Variable variables+=Variable*)? instructions=InstructionList)
	 */
	protected void sequence_Function(ISerializationContext context, Function semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Goto returns Goto
	 *
	 * Constraint:
	 *     url=STRING
	 */
	protected void sequence_Goto(ISerializationContext context, Goto semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BotoLangPackage.Literals.GOTO__URL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BotoLangPackage.Literals.GOTO__URL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGotoAccess().getUrlSTRINGTerminalRuleCall_1_0(), semanticObject.getUrl());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Html returns Html
	 *
	 * Constraint:
	 *     (tag='button' | tag='field' | tag='link')
	 */
	protected void sequence_Html(ISerializationContext context, Html semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InstructionList returns InstructionList
	 *
	 * Constraint:
	 *     (
	 *         instructions+=Goto | 
	 *         instructions+=Click | 
	 *         instructions+=Check | 
	 *         instructions+=Fill | 
	 *         instructions+=Put | 
	 *         instructions+=FunctionCall
	 *     )+
	 */
	protected void sequence_InstructionList(ISerializationContext context, InstructionList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     ((functions+=Function+ browsers+=Browser+) | browsers+=Browser+)?
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Object returns Object
	 *
	 * Constraint:
	 *     ((html=Html param=STRING) | variable=[Variable|ID])
	 */
	protected void sequence_Object(ISerializationContext context, org.emn.fil.boto.botoLang.Object semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Predicate returns Predicate
	 *
	 * Constraint:
	 *     (
	 *         (keyword='contains' not='not'? (stringValue=STRING | variable=[Variable|ID])) | 
	 *         (keyword='length' (secondKeyword='=' | secondKeyword='>' | secondKeyword='<' | secondKeyword='>=' | secondKeyword='<=') value+=INT+)
	 *     )
	 */
	protected void sequence_Predicate(ISerializationContext context, Predicate semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Put returns Put
	 *
	 * Constraint:
	 *     ((object=Object | string=STRING) variable=Variable)
	 */
	protected void sequence_Put(ISerializationContext context, Put semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, BotoLangPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, BotoLangPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
